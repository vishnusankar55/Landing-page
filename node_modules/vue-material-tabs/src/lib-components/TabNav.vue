<template>
  <div v-resize.debounce="resizable" :class="classes">
    <div class="vmt__nav__prev">
      <Btn v-if="pagination.has" :disabled="!paginateIndicator.prev" @click="paginationTo('prev')" />
    </div>
    <nav v-touch="paginationTo" ref="nav" class="tab__nav">
      <ul ref="navItems" class="vmt__nav__items" :style="transform">
        <li
          v-ripple="ripple && !navItem.disabled"
          v-for="navItem in navItems"
          :key="navItem.model"
          :ref="navItem.model"
          class="vmt__nav__item"
          :class="{
            active: navItem.model === tabItemActive.model,
            disabled: navItem.disabled,
          }"
          :style="getActiveColor(navItem)"
          @click.prevent="select(navItem)"
        >
          <VNode :node="navItem.nameSlot" :name="navItem.name" />
        </li>
        <hr v-if="navSlider" ref="slider" class="vmt__tab__slider" />
      </ul>
    </nav>
    <div class="vmt__nav__next">
      <Btn v-if="pagination.has" :disabled="!paginateIndicator.next" @click="paginationTo('next')" />
    </div>
  </div>
</template>

<script>
import ripple from "./directives/ripple";
import resize from "./directives/resize";
import touch from "./directives/touch";
import Btn from "./Btn";

export default {
  inject: ["theme"],

  components: {
    Btn,
    VNode: {
      functional: true,
      render: (h, { props }) => {
        return props.node ? props.node : h("span", props.name);
      },
    },
  },

  directives: {
    ripple,
    resize,
    touch,
  },

  props: {
    vertical: Boolean,
    navSlider: Boolean,
    ripple: Boolean,
    navAuto: Boolean,
    navItems: {
      type: Array,
      required: true,
    },
    tabItemActive: {
      type: Object,
      default: () => {},
    },
  },

  data: () => ({
    pagination: {
      has: false,
      maxOffset: 0,
      minOffset: 0,
      translate: 0,
      offset: 0,
    },
  }),

  computed: {
    classes() {
      return {
        vmt__nav: true,
        "vmt__nav--vertical": this.vertical,
        "vmt__nav--auto": this.navAuto && !this.vertical,
      };
    },

    transform() {
      return `transform: translate${this.vertical ? "Y" : "X"}(-${this.pagination.translate}px)`;
    },

    paginateIndicator() {
      const { translate, maxOffset } = this.pagination;
      return {
        next: translate < maxOffset,
        prev: translate > 0,
      };
    },

    orientation() {
      return this.vertical ? "portrait" : "landscape";
    },

    sliderElement() {
      return this.$refs?.slider;
    },
  },

  watch: {
    navItems: "resizable",
    // Force recalc the pagination offsets
    // when the orientation/navItems is change;
    vertical() {
      Object.assign(this.$data, this.$options.data());
      this.resizable();
    },

    tabItemActive(tabItemActive) {
      this.setSliderPosition();
      if (this.pagination.has && tabItemActive?.model) {
        const navItemActiveElement = this.$refs[tabItemActive.model][0];
        const navElement = this.$refs.nav;

        const navActiveItemRectsCollection = navItemActiveElement?.getClientRects()?.[0];
        const navRectsCollection = navElement?.getClientRects()?.[0];

        if (!navActiveItemRectsCollection || !navRectsCollection) return;

        const { translate, maxOffset } = this.pagination;
        let toTranslate = translate;

        // Portrait
        if (this.orientation === "portrait") {
          if (navActiveItemRectsCollection.bottom > navRectsCollection.bottom) {
            toTranslate = toTranslate + navActiveItemRectsCollection.height;
          }

          if (navActiveItemRectsCollection.top < navRectsCollection.top) {
            toTranslate =
              navActiveItemRectsCollection.height > toTranslate ? 0 : toTranslate - navActiveItemRectsCollection.height;
          }
        }

        if (this.orientation === "landscape") {
          if (navActiveItemRectsCollection.right > navRectsCollection.right) {
            toTranslate = toTranslate + navActiveItemRectsCollection.width;
          }
          if (navActiveItemRectsCollection.left < navRectsCollection.left) {
            toTranslate =
              navActiveItemRectsCollection.width > toTranslate ? 0 : toTranslate - navActiveItemRectsCollection.width;
          }

          if (toTranslate > maxOffset) {
            toTranslate = toTranslate + (maxOffset - toTranslate);
          }
        }

        this.pagination.translate = Math.abs(toTranslate);
      }
    },
  },

  mounted() {
    const { nav, navItem, slider } = this.theme;
    this.$el.style.background = nav;
    this.$refs.navItems.style.color = navItem;
    if (this.sliderElement) this.sliderElement.style.background = slider;
  },

  methods: {
    select(navItem) {
      this.$emit("select", navItem);
    },

    async setSliderPosition() {
      await this.$nextTick();

      const model = this.tabItemActive?.model;
      if (!model) return;

      const navItemsRectsCollection = this.$refs.navItems?.getClientRects()?.[0];
      const navActiveItemRectsCollection = this.$refs[model][0]?.getClientRects()?.[0];

      if (this.sliderElement) {
        Object.assign(
          this.sliderElement?.style,
          {
            portrait: {
              height: navActiveItemRectsCollection.height + "px",
              top: navActiveItemRectsCollection.top - navItemsRectsCollection.top + "px",
              width: "",
              left: "",
            },
            landscape: {
              width: navActiveItemRectsCollection.width + "px",
              left: navActiveItemRectsCollection.left - navItemsRectsCollection.left + "px",
              height: "",
              top: "",
            },
          }[this.orientation]
        );
      }
    },

    setPaginationSettings() {
      const paginationRefactory = (has, maxOffset, minOffset) => ({
        has,
        maxOffset,
        minOffset,
        offset: minOffset,
      });
      const navElement = this.$refs.nav;
      const navElementWidth = navElement?.offsetWidth;
      const navElementHeight = navElement?.offsetHeight;
      const navItemsElement = this.$refs?.navItems;
      const navItemsElementWidth = navItemsElement?.offsetWidth;
      const navItemsElementHeight = [...navItemsElement?.children]
        .slice(0, -1)
        .reduce((previousValue, currentValue) => previousValue + currentValue.offsetHeight, 0);
      Object.assign(
        this.pagination,
        {
          portrait: paginationRefactory(
            navItemsElementHeight > navElementHeight,
            navItemsElementHeight - navElementHeight,
            navElementHeight
          ),
          landscape: paginationRefactory(
            navItemsElementWidth > navElementWidth,
            navItemsElementWidth - navElementWidth,
            navElementWidth
          ),
        }[this.orientation]
      );

      if (this.pagination.maxOffset === 0) {
        this.pagination.translate = 0;
      }
    },

    paginationTo(to) {
      const { maxOffset, offset, translate, minOffset } = this.pagination;

      if (to === "prev" && this.paginateIndicator.prev) {
        if (offset <= minOffset) {
          this.pagination.offset = minOffset;
        }

        if (translate - offset < offset) {
          this.pagination.translate = 0;
          return;
        }

        this.pagination.translate = translate - offset;
      }

      if (to === "next" && this.paginateIndicator.next) {
        if (translate + offset > maxOffset) {
          this.pagination.offset = maxOffset - translate;
        }
        this.pagination.translate = translate + this.pagination.offset;
      }
    },

    async resizable() {
      await this.$nextTick();

      this.setPaginationSettings();
      this.setSliderPosition();
    },

    getActiveColor({ model }) {
      if (model === this.tabItemActive.model) {
        return { color: this.theme.navActiveItem };
      }
    },
  },
};
</script>

<style scoped>
.vmt__nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
  vertical-align: middle;
  max-width: 100%;
  flex: 0 1 auto;
  position: relative;
  contain: content;
}

.vmt__nav .vmt__nav__prev,
.vmt__nav__next {
  flex: 1 40px;
  min-width: 40px;
}

.vmt__nav__next >>> .vmt__btn svg {
  transform: rotate(180deg);
}

.vmt__nav nav {
  position: relative;
  display: flex;
  overflow: hidden;
  flex: 1 100%;
}

.vmt__nav__items {
  position: relative;
  display: flex;
  margin: 0;
  padding: 0;
  flex: 1 auto;
  transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
  height: 100%;
}

.vmt__nav__items .vmt__nav__item {
  list-style: none;
  text-align: center;
  cursor: pointer;
  padding: 0.9rem 1rem;
  letter-spacing: 0.0892857143em;
  display: flex;
  justify-content: center;
  align-items: center;
  text-align: center;
  text-transform: uppercase;
  font-size: 0.875rem;
  font-weight: 500;
  white-space: normal;
  transition: background 0.1s ease;
  position: relative;
  overflow: hidden;
  min-width: 90px;
  max-width: 360px;
  user-select: none;
}

.vmt__nav__items .vmt__nav__item:hover:not(.disabled, .active) {
  background: hsla(0, 0%, 100%, 0.09);
}

.vmt__nav__items .active:hover {
  background: hsla(0, 0%, 100%, 0.18);
}

.vmt__nav__items .disabled {
  background: #6969694f;
}

.vmt__tab__slider {
  height: 2px;
  width: 2px;
  border: none;
  margin: 0;
  padding: 0;
  bottom: 0;
  position: absolute;
  transition: left 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), top 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
}

/* Vertical */
.vmt__nav--vertical {
  flex-direction: column;
}

.vmt__nav--vertical .vmt__nav__items {
  flex-direction: column;
  flex: 1 auto;
  position: relative;
}

.vmt__nav--vertical .vmt__nav__item * {
  padding: 0;
  margin: 0;
}

.vmt__nav--vertical >>> .vmt__nav__prev svg {
  transform: rotate(90deg);
}

.vmt__nav--vertical >>> .vmt__nav__next svg {
  transform: rotate(270deg);
}

.vmt__nav--vertical .vmt__nav__item {
  justify-content: left;
  padding-top: 1.6rem;
  padding-bottom: 1.6rem;
}

.vmt__nav--auto .vmt__nav__item {
  flex: 1 auto;
}
</style>

<style>
.ripple {
  z-index: 2;
  background-color: hsla(0, 0%, 100%, 0.23);
  border-radius: 50%;
  position: absolute;
  transform: scale(0);
  animation: ripple 0.6s linear;
}

@keyframes ripple {
  to {
    transform: scale(2.5);
    opacity: 0;
  }
}
</style>
