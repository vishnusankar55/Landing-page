<template>
  <div :class="classes">
    <slot name="nav" :items="navItems" :active="tabItemActive">
      <TabNav
        v-bind="{
          ripple,
          navAuto,
          navItems,
          vertical,
          navSlider,
          tabItemActive,
        }"
        @select="activeTabItem"
      />
    </slot>
    <div v-touch="switchTabItem" class="tabs__content">
      <slot />
    </div>
  </div>
</template>

<script>
import TabNav from "./TabNav";
import touch from "./directives/touch";
import $themes from "./themes";

export default {
  name: "Tabs",

  components: {
    TabNav,
  },

  directives: {
    touch,
  },

  provide() {
    return {
      theme: this.getTheme,
    };
  },

  props: {
    value: [Number, String],

    theme: {
      type: [Object, String],
      default: "default",
    },
    vertical: Boolean,
    ripple: {
      type: Boolean,
      default: true,
    },
    slideDuration: {
      type: [String, Number],
      default: 200,
    },
    slideVertical: Boolean,
    slide: {
      type: Boolean,
      default: true,
    },
    navAuto: Boolean,
    navSlider: {
      type: Boolean,
      default: true,
    },
    noTouch: Boolean,
  },

  data: () => ({
    slideSide: "",
    navItems: [],
    tabItemActive: {
      model: "",
      name: "",
      disabled: false,
    },
    tabItemIndexes: {
      current: 0,
      last: 0,
      previous: 0,
    },
    tabItems: [],
  }),

  computed: {
    classes() {
      return {
        tabs: true,
        "tabs--vertical": this.vertical,
      };
    },

    transition() {
      return {
        slide: this.slide,
        duration: this.slide ? this.slideDuration : 0,
        vertical: this.slideVertical,
        side: this.slideSide,
      };
    },

    getTheme() {
      if (typeof this.theme === "string") {
        return $themes[this.theme] || $themes.default;
      } else if (typeof this.theme === "object" && this.theme) {
        return this.theme;
      }
      return $themes.default;
    },
  },

  watch: {
    tabItemActive(newTabItem, oldTabItem) {
      this.tabItemIndexes.previous = this.finTabIndex(oldTabItem);
      this.tabItemIndexes.current = this.finTabIndex(newTabItem);

      if (!newTabItem?.model) return;

      this.tabItems[this.tabItemIndexes.current].activeModel = newTabItem.model;
      // eslint-disable-next-line no-extra-boolean-cast
      if (Boolean(~this.tabItemIndexes.previous)) {
        this.setTabItemTransitionSide();
        this.tabItems[this.tabItemIndexes.previous].activeModel = newTabItem.model;
      }
    },

    value: {
      immediate: true,
      handler(value = 0) {
        this.$nextTick(() => {
          const navItem = this.navItems?.[value];
          navItem && this.activeTabItem(navItem);
        });
      },
    },
  },

  methods: {
    register(tabItemInstance) {
      if (this.isTabItemComponent(tabItemInstance)) {
        this.tabItems.push(tabItemInstance);
        this.setNavItem(tabItemInstance);
      }
    },

    unRegister(tabItemInstance) {
      if (this.isTabItemComponent(tabItemInstance)) {
        this.disableTabItem(tabItemInstance.ownNavItemIndex);
        this.tabItems.splice(this.finTabIndex(tabItemInstance), 1);
        this.navItems.splice(tabItemInstance.ownNavItemIndex, 1);
        this.tabItemIndexes.last = this.navItems.length - 1;
      }
    },

    isTabItemComponent({ $options }) {
      return $options?.name === "TabItem";
    },

    setNavItem({ model, name, disabled, $slots }) {
      this.navItems.push({
        model,
        name,
        disabled,
        nameSlot: $slots.name?.[0],
      });
      this.tabItemIndexes.last = this.navItems.length - 1;
    },

    activeTabItem(tabItem) {
      if (!tabItem?.disabled) {
        this.tabItemActive = tabItem;
        this.$emit("input", this.finTabIndex(tabItem));
      }
    },

    disableTabItem(tabItemIndex) {
      const { current, last } = this.tabItemIndexes;
      if (tabItemIndex === current) {
        const nextTabItem = current === last ? current - 1 : current + 1;
        this.activeTabItem(this.navItems[nextTabItem]);
      }
    },

    setTabItemTransitionSide() {
      const { current, previous } = this.tabItemIndexes;
      this.slideSide = current > previous ? "right" : "left";
    },

    switchTabItem(to) {
      if (!this.noTouch) {
        const { current, last } = this.tabItemIndexes;

        const switchTab = (count) => {
          const tabItem = this.navItems?.[current + count];
          tabItem && this.activeTabItem(tabItem);
        };

        to === "next" && current < last && switchTab(1);
        to === "prev" && current > 0 && switchTab(-1);
      }
    },

    finTabIndex(tab) {
      return this.tabItems.findIndex((el) => el.model === tab?.model);
    },
  },
};
</script>
<style scoped>
.tabs {
  background: white;
  display: flex;
  flex-direction: column;
  border-radius: 0.23rem;
  height: 100%;
  width: 100%;
}

.tabs__content {
  display: flex;
  position: relative;
  justify-content: center;
  align-items: center;

  overflow: hidden;
}

.tabs--vertical {
  flex-direction: row;
}
</style>
